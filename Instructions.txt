# Copilot Instructions for Monster Dungeon

# Feature: Base Combat Screen (Main Gameplay HUD)

Create a new WPF UserControl named **CombatScreen.xaml** under `Presentation/Views/Game/`.
This will be the primary gameplay screen for combat encounters.

## Layout Overview

Design this screen using a fixed 16:9 area (1280x720) with three main columns:

* Left Panel: Player input & contextual options
* Center Panel: Combat grid
* Right Panel: Player info (image, stats, equipment)
* Top Header: Game title/info area

Use `Grid` as the root layout with defined row/column structure.

---

### 1️⃣ ROOT GRID SETUP

* Outer container: `<Grid>` inside a `<Viewbox>` (for resolution scaling).
* Grid rows:

  * Row 0: Header (auto height)
  * Row 1: Main content (stretch)
* Grid columns:

  * Three main areas: Left, Center, Right

```xml
<Grid.RowDefinitions>
    <RowDefinition Height="Auto"/>
    <RowDefinition Height="*"/>
</Grid.RowDefinitions>

<Grid.ColumnDefinitions>
    <ColumnDefinition Width="3*"/>  <!-- Left -->
    <ColumnDefinition Width="6*"/>  <!-- Center -->
    <ColumnDefinition Width="3*"/>  <!-- Right -->
</Grid.ColumnDefinitions>
```

---

### 2️⃣ HEADER AREA

* Add a `<Border>` across the top row with a dark background and light text.
* TextBlock centered: “Monster Dungeon – Combat Mode”
* Bindable area for future data (e.g., gold, level, status).

---

### 3️⃣ LEFT PANEL

Inside the left column, create two vertical sections:

#### a. Context Display Area

* Use a `<Border>` with padding and a ScrollViewer.
* Placeholder `TextBlock` that says: “Context Display Area (Spells, Inventory, etc.)”
* This will later host dynamic content bound to a ViewModel collection.

#### b. Action Buttons

* Below the display area, add a horizontal `StackPanel` of three buttons:

  * Attack
  * Spells
  * Items
* Each button triggers a command (`AttackCommand`, `OpenSpellsCommand`, `OpenItemsCommand`).

---

### 4️⃣ CENTER PANEL — COMBAT FIELD

* Use a `<UniformGrid>` for the combat field.
* Size: 8 columns × 10 rows (matching GridService layout).
* Each cell: bordered square placeholder (for now, colored boxes or images later).
* Centered label: “Combat Field”.

---

### 5️⃣ RIGHT PANEL — PLAYER INFO

Stack three bordered areas vertically:

* Player Image placeholder
* Player Stats section (for HP, MP, Level)
* Player Equipment slots (Weapon, Armor, Accessory)

Each section can contain just a `TextBlock` with its label for now.

---

### 6️⃣ VIEWMODEL SETUP

Create a new file `CombatViewModel.cs` under `Application/ViewModels/`.
Use `[ObservableProperty]` for:

* `SelectedContextMenu` (string)
* `CurrentGrid` (2D ObservableCollection<Tile> for future use)
* `PlayerInfo` (object placeholder)
  Add `RelayCommand` for:
* `AttackCommand`
* `OpenSpellsCommand`
* `OpenItemsCommand`

Each command should update `SelectedContextMenu` to show the chosen category in the left panel.

---

### 7️⃣ MAINWINDOW INTEGRATION

In `MainViewModel`, add property:

```csharp
public CombatViewModel CombatView { get; }
```

Resolve via DI and bind it to a `ContentControl` in `MainWindow.xaml` when the game is in combat mode.

Example placeholder:

```xml
<ContentControl Content="{Binding CombatView}" />
```

---

### 8️⃣ STYLING

Use simple red headers and brownish borders (as in the reference image).
Define a few colors in `Resources/Colors.xaml`:

* `HUDBackground = #1a1a2e`
* `HUDAccent = #e94560`
* `HUDOutline = #b36b3d`
* `HUDText = #fff`

---

### 9️⃣ FILES TO ADD / MODIFY

* [NEW] `Presentation/Views/Game/CombatScreen.xaml`
* [NEW] `Application/ViewModels/CombatViewModel.cs`
* [MODIFY] `App.xaml.cs` → Register `CombatViewModel`
* [MODIFY] `MainViewModel.cs` → Add reference property for CombatView
* [MODIFY] `MainWindow.xaml` → Insert CombatScreen for active gameplay state

---

### 🔧 ADDITIONAL IMPLEMENTATION DETAILS

* Include all setup and integration steps above for Copilot generation.
* Ensure all bindings, containers, and empty elements exist to accept future expansions.
* Do not add temporary data or mock UI content.
* Maintain consistency with existing theme colors and MVVM pattern.

Result:
A fully functional **CombatScreen UI framework** that mirrors the reference layout, obeys the fixed aspect ratio, and is ready for binding to gameplay systems later — with no temp logic or data.
