# Monster Dungeon - Project Information for ChatGPT

---

## PROJECT OVERVIEW

**Monster Dungeon** is a WPF-based retro 8-bit dungeon crawler game built using .NET Framework 4.7.2. The project follows Domain-Driven Design (DDD) principles with MVVM architecture pattern for clean separation of concerns.

**Project Type**: WPF Desktop Application (Windows Presentation Foundation)
**Target Framework**: .NET Framework 4.7.2
**Architecture Pattern**: Domain-Driven Design (DDD) + MVVM
**Development Environment**: Visual Studio (Windows)

---

## PROJECT STRUCTURE

The project uses a **single-project architecture** with logical folder separation instead of multiple project references. This simplifies dependency management while maintaining architectural boundaries.

### Folder Organization:

```
MonsterDungeon/
??? Domain/     # Core business logic and entities
?   ??? Entities/      # Domain models (Player, Enemy, Item, Spell, Tile, Inventory)
?   ??? Enums/     # Game enumerations (GameEnums.cs)
? ??? Interfaces/       # Domain interfaces (empty, ready for future use)
?   ??? Services/       # Domain services (EnemyFactory, ThemeManager)
?
??? Application/        # Application logic layer
?   ??? Commands/     # MVVM commands (empty, ready for future use)
? ??? Models/  # Application DTOs (empty, ready for future use)
?   ??? Queries/                # Query handlers (empty, ready for future use)
?   ??? Services/   # Application services (GridService, GameFlowService)
?   ??? ViewModels/   # MVVM ViewModels (MainViewModel)
?
??? Infrastructure/    # External concerns (persistence, I/O, etc.)
?   ??? Persistence/ # Data persistence (empty, ready for future use)
?   ??? Repositories/    # Data repositories (empty, ready for future use)
?   ??? Services/   # Infrastructure services (empty, ready for future use)
?
??? Presentation/             # UI layer (WPF)
    ??? Assets/      # Game assets
    ?   ??? Icons/       # UI icons
  ?   ??? Music/              # Sound effects and music
    ?   ??? Sprites/      # Character/enemy sprites (32x32 or 16x16 pixels)
    ?   ??? UI/  # UI elements
    ??? Controls/           # Custom WPF controls (empty, ready for future use)
    ??? Resources/          # XAML resources (empty, ready for future use)
    ??? Styles/          # WPF styles (empty, ready for future use)
    ??? Views/            # XAML windows and views (MainWindow.xaml)
```

---

## NUGET PACKAGES & DEPENDENCIES

### Core Packages (Required):
- **CommunityToolkit.Mvvm** v8.4.0 - Modern MVVM framework with source generators
- **Microsoft.Extensions.DependencyInjection** v8.0.0 - Dependency injection container
- **Microsoft.Extensions.Hosting** v8.0.0 - Application hosting and lifetime management
- **System.Text.Json** v8.0.0 - JSON serialization (for save/load functionality)

### UI Enhancement Packages (Optional, Installed):
- **MahApps.Metro** v2.4.11 - Modern UI controls and themes for WPF
- **FontAwesome.Sharp** v6.6.0 - Icon library for UI elements
- **ControlzEx** v4.4.0 - Dependency for MahApps.Metro

### Supporting Packages:
- **Microsoft.Extensions.Configuration*** v8.0.0 - Configuration management
- **Microsoft.Extensions.Logging*** v8.0.0 - Logging infrastructure
- **Microsoft.Xaml.Behaviors.Wpf** v1.1.19 - XAML behaviors for interactive UI
- **System.ComponentModel.Annotations** v5.0.0 - Data validation attributes

All packages are installed and referenced via `packages.config` (NuGet Packages.config format for .NET Framework).

---

## DEPENDENCY INJECTION CONFIGURATION

The application uses **Microsoft.Extensions.Hosting** for modern DI container setup in a WPF application.

### Configuration Location: `App.xaml.cs`

```csharp
public static IHost AppHost { get; private set; }

// Services Registered:
- MainWindow (Singleton)
- MainViewModel (Singleton)
- GameFlowService (Singleton)
- GridService (Singleton)
- EnemyFactory (Singleton)
- ThemeManager (Singleton)
```

**Startup Flow**:
1. `App.xaml.cs` constructor builds the IHost with DI container
2. `OnStartup()` starts the host and resolves `MainWindow` from DI
3. `MainWindow` receives `MainViewModel` via constructor injection
4. All services are available throughout the application lifetime

**Important**: The project uses **programmatic startup** (no `StartupUri` in App.xaml), allowing full DI integration.

---

## DOMAIN ENTITIES (Core Game Models)

### 1. Player (`Domain/Entities/Player.cs`)
**Properties**:
- Position: X, Y (grid coordinates)
- Stats: Health, MaxHealth, Attack, Defense
- Progression: Level, Experience, Gold
- Equipment: Inventory (reference to Inventory class)

**Key Methods**:
- `TakeDamage(int damage)` - Apply damage with defense calculation
- `Heal(int amount)` - Restore health (capped at MaxHealth)
- `GainExperience(int xp)` - Add XP and handle level-ups
- `LevelUp()` - Increase stats on level up

**Starting Stats**:
- Position: (4, 8) - Center-bottom of grid
- Health: 100/100
- Attack: 10, Defense: 5
- Level: 1

### 2. Enemy (`Domain/Entities/Enemy.cs`)
**Properties**:
- Position: X, Y
- Type: EnemyType enum (Goblin, Skeleton, Orc, Wraith, etc.)
- Stats: Health, MaxHealth, Attack, Defense
- Flags: IsBlock (obstacle), IsBoss (boss enemy)
- Rewards: GoldDrop, ExperienceDrop

**Key Methods**:
- `TakeDamage(int damage)` - Apply damage with defense
- `GetAttackDamage()` - Returns attack value with random variance

### 3. Inventory (`Domain/Entities/Inventory.cs`)
**Features**:
- Max Capacity: 20 items
- Equipment Slots: EquippedWeapon, EquippedArmor
- Item Management: Add, Remove, GetItem
- Equipment System: EquipWeapon(), EquipArmor()
- Stat Calculation: GetTotalAttackBonus(), GetTotalDefenseBonus()

### 4. Item (`Domain/Entities/Item.cs`)
**Properties**:
- Metadata: Name, Description
- Type: ItemType (Weapon, Armor, Consumable, QuestItem, Material)
- Rarity: ItemRarity (Common, Uncommon, Rare, Epic, Legendary)
- Stats: AttackBonus, DefenseBonus, HealthBonus, Value
- Flags: IsConsumable

### 5. Spell (`Domain/Entities/Spell.cs`)
**Properties**:
- Metadata: Name, Description
- Costs: ManaCost, Damage
- Type: SpellType (Offensive, Defensive, Healing, Utility)
- Affinity: ElementalAffinity (Fire, Ice, Lightning, etc.)
- Cooldown System: Cooldown, CurrentCooldown, IsAvailable

**Key Methods**:
- `Use()` - Trigger cooldown
- `ReduceCooldown()` - Decrease cooldown counter

### 6. Tile (`Domain/Entities/Tile.cs`)
**Properties**:
- Position: X, Y
- State: IsOccupied, IsWalkable
- Content: TileContent enum (Empty, Player, Enemy, Item, Block, Trap)

---

## GAME ENUMERATIONS

Located in `Domain/Enums/GameEnums.cs`:

### EnemyType
- Goblin, Skeleton, Orc, Wraith, Slime, Zombie, Vampire, Dragon, Block, Boss

### DungeonTheme
- Caverns, Crypt, Volcano, IceCavern, Forest, Swamp, Castle

### ElementalAffinity
- None, Fire, Ice, Lightning, Earth, Light, Dark, Wind, Water

### SpellType
- Offensive, Defensive, Healing, Utility

### ItemType
- Weapon, Armor, Consumable, QuestItem, Material

### ItemRarity
- Common, Uncommon, Rare, Epic, Legendary

---

## CORE GAME SERVICES

### 1. GridService (`Application/Services/GridService.cs`)
**Purpose**: Manages the 8x10 tile grid system where gameplay occurs.

**Constants**:
- GridWidth: 8 tiles
- GridHeight: 10 tiles (visible rows)

**Key Methods**:
- `MovePlayer(int newX, int newY)` - Move player to new position
- `DescendEnemies(List<Enemy> enemies)` - Move all enemies down one tile
- `IsValidPosition(int x, int y)` - Check grid bounds
- `GetTile(int x, int y)` - Get tile at position
- `IsTileOccupied(int x, int y)` - Check if tile has entity
- `SetPlayer(Player player)` - Initialize player on grid

**Grid Mechanics**:
- 2D array of Tile objects
- Tracks occupancy for collision detection
- Enemies descend one row each turn after player movement

### 2. EnemyFactory (`Domain/Services/EnemyFactory.cs`)
**Purpose**: Spawns enemies and obstacles based on difficulty and theme.

**Key Methods**:
- `SpawnEnemy(int difficultyLevel, DungeonTheme theme)` - Create themed enemy
- `SpawnBlock(int difficultyLevel)` - Create obstacle with high HP/Defense
- `SpawnBoss(int level, DungeonTheme theme)` - Create boss encounter
- `GetSpawnRate(int difficulty)` - Calculate spawn frequency

**Difficulty Scaling**:
- Health: BaseHealth + (difficulty × 2)
- Attack: BaseAttack + (difficulty / 2)
- Defense: BaseDefense + (difficulty / 3)

**Enemy Base Stats**:
- Goblin: 10 HP, 3 ATK, 1 DEF
- Skeleton: 15 HP, 5 ATK, 3 DEF
- Orc: 25 HP, 8 ATK, 5 DEF
- Wraith: 20 HP, 7 ATK, 2 DEF
- Block: 50 HP, 0 ATK, 999 DEF (obstacle)

### 3. ThemeManager (`Domain/Services/ThemeManager.cs`)
**Purpose**: Manages dungeon themes, visual palettes, and elemental affinities.

**Current Themes**:
- **Caverns** (Earth) - Difficulty: 1.0x
- **Crypt** (Dark) - Difficulty: 1.2x
- **Volcano** (Fire) - Difficulty: 1.5x
- **Ice Cavern** (Ice) - Difficulty: 1.4x

**Theme Data Structure**:
- Name, PrimaryColor, SecondaryColor
- ElementalAffinity, DifficultyModifier, Description

**Key Methods**:
- `ChangeTheme(DungeonTheme newTheme)` - Switch theme
- `GetCurrentThemeData()` - Get theme info
- `GetThemeSpawnModifier()` - Get difficulty multiplier
- `HasAffinityBonus(ElementalAffinity)` - Check spell synergy
- `GetAffinityMultiplier(ElementalAffinity)` - Calculate damage modifier

**Affinity System**:
- Matching affinity: 1.5× damage (50% bonus)
- Opposing affinity: 0.5× damage (50% penalty)
- Neutral: 1.0× damage

**Opposing Affinities**:
- Fire ? Ice
- Light ? Dark

### 4. GameFlowService (`Application/Services/GameFlowService.cs`)
**Purpose**: Orchestrates main gameplay loop and turn-based combat.

**Game State**:
- Player, Enemies (List), CurrentLevel, TurnCount, IsGameActive

**Key Methods**:
- `StartNewGame()` - Initialize new game session
- `StartEncounterAsync()` - Begin new level/encounter
- `EndEncounterAsync()` - Complete level and progress
- `ProcessPlayerMove(int newX, int newY)` - Handle movement turn
- `ProcessPlayerAttack(int targetX, int targetY)` - Handle combat

**Turn Flow**:
1. Player moves or attacks
2. Turn counter increments
3. Enemies descend one tile
4. New enemy spawns every 3 turns
5. Check collisions (player-enemy contact)
6. Apply damage and check victory/defeat

**Level Progression**:
- Theme changes every 5 levels
- Enemy count: 3 + currentLevel
- Cycles through themes: Caverns ? Crypt ? Volcano ? Ice Cavern

---

## MVVM IMPLEMENTATION

### MainViewModel (`Application/ViewModels/MainViewModel.cs`)
**Base Class**: `ObservableObject` (from CommunityToolkit.Mvvm)

**Properties** (using source generators):
```csharp
[ObservableProperty]
private string title = "Monster Dungeon";

[ObservableProperty]
private string version = "v0.1.0-alpha";
```

**Note**: Uses C# source generators to auto-generate `INotifyPropertyChanged` boilerplate.

### MainWindow (`Presentation/Views/MainWindow.xaml`)
**Features**:
- Window size: 800×600
- Centered on screen
- Custom background color: #1a1a2e (dark blue-gray)
- Header section with title and version display
- Main content frame for navigation

**Data Binding**:
- Title: Bound to `MainViewModel.Title`
- Version: Bound to `MainViewModel.Version`
- DataContext injected via constructor

---

## VISUAL DESIGN

**Art Style**: Retro 8-bit pixel art
**Sprite Sizes**: 32×32 pixels or 16×16 pixels
**Color Palette**: Theme-based (defined in ThemeManager)

**Asset Folders**:
- `/Assets/Sprites` - Character and enemy sprites
- `/Assets/Icons` - UI icons and buttons
- `/Assets/UI` - Interface elements
- `/Assets/Music` - Sound effects and background music

**UI Colors** (MainWindow):
- Background: #1a1a2e (dark blue-gray)
- Header: #16213e (darker blue)
- Accent: #e94560 (red/pink)
- Text: #a0a0a0 (light gray)

---

## CURRENT PROJECT STATUS

### ? COMPLETED FEATURES:
1. Project structure and folder organization
2. All NuGet packages installed and configured
3. Dependency Injection setup with Microsoft.Extensions.Hosting
4. Complete Domain layer:
   - All entities (Player, Enemy, Item, Spell, Tile, Inventory)
   - All enumerations (GameEnums)
   - Domain services (EnemyFactory, ThemeManager)
5. Application layer:
   - GridService with 8×10 grid system
   - GameFlowService with turn-based combat
   - MainViewModel with MVVM pattern
6. Presentation layer:
   - MainWindow with header and navigation frame
   - Asset folder structure
7. Build system: **Project builds successfully**

### ?? NOT YET IMPLEMENTED:
1. Actual UI/gameplay views (beyond MainWindow shell)
2. Visual rendering of grid, player, and enemies
3. Input handling (keyboard/mouse for movement)
4. Combat animations and visual feedback
5. Town system (shops, NPCs, quest givers)
6. Save/Load system
7. Sound effects and music playback
8. Item/Spell selection UI
9. Boss encounter mechanics
10. Victory/defeat screens

### ?? READY FOR DEVELOPMENT:
- Infrastructure layer folders (Persistence, Repositories, Services)
- Additional ViewModels for game screens
- Commands for user actions
- Custom WPF controls for game UI
- Styles and resources for visual theming

---

## IMPORTANT TECHNICAL NOTES

### 1. Single Project Structure
Unlike the instructions which suggested multiple projects (Presentation ? Application ? Domain ? Infrastructure), this implementation uses a **single project with logical folder separation**. This simplifies:
- Build configuration
- Dependency management
- Deployment
- Debugging

The architectural boundaries are maintained through folder organization and namespace conventions.

### 2. Programmatic WPF Startup
The application does NOT use `StartupUri` in App.xaml. Instead:
- `App.xaml.cs` builds IHost in constructor
- `OnStartup()` resolves MainWindow from DI container
- MainWindow.Show() is called programmatically

This enables full dependency injection throughout the application.

### 3. .NET Framework vs .NET Core/5+
The project targets **.NET Framework 4.7.2** (not modern .NET). This means:
- Uses `packages.config` instead of PackageReference
- Requires Windows to run
- WPF is available (WPF was made cross-platform in .NET Core 3.0+)
- Some newer C# features may not be available

### 4. CommunityToolkit.Mvvm Source Generators
The project uses `[ObservableProperty]` attribute which requires:
- `partial` class declarations on ViewModels
- C# 8.0+ language features enabled
- Source generators support in Visual Studio

### 5. Grid System Design
The 8-tile width was chosen for retro game balance:
- Wide enough for tactical positioning
- Narrow enough to see all options at once
- Matches classic dungeon crawler grid sizes

Enemies descend automatically, creating time pressure without real-time mechanics.

---

## GAMEPLAY MECHANICS SUMMARY

### Core Loop:
1. Player spawns at center-bottom of 8×10 grid
2. Enemies spawn at top and descend each turn
3. Player can move or attack
4. Enemies damage player on contact
5. Defeat all enemies to progress
6. Themes change every 5 levels
7. Difficulty scales with level

### Combat System:
- **Damage Formula**: Max(Attack - Defense, 1)
- **Experience**: Gain XP from defeated enemies
- **Leveling**: 100 XP × Level required per level-up
- **Level Benefits**: +10 MaxHP, +2 ATK, +1 DEF

### Theme System:
- Each theme has elemental affinity
- Matching spell affinity: +50% damage
- Opposing affinity: -50% damage
- Themes affect difficulty and visuals

### Inventory System:
- 20-item capacity
- Equipment slots: Weapon, Armor
- Items provide stat bonuses
- Consumables for healing/buffs

---

## NEXT DEVELOPMENT STEPS (Recommendations)

### Phase 1: Core Gameplay Rendering
1. Create GameView.xaml with grid visualization
2. Implement sprite rendering system
3. Add player movement input handling
4. Display enemies on grid
5. Visual feedback for attacks/damage

### Phase 2: Combat & UI Polish
1. Implement spell casting system
2. Create inventory UI window
3. Add health/mana bars
4. Combat animations
5. Particle effects for spells

### Phase 3: Meta-Game Systems
1. Town view with shops and NPCs
2. Save/Load functionality
3. Quest system
4. Crafting system
5. Achievement tracking

### Phase 4: Content & Balance
1. Add more enemy types
2. Implement boss encounters
3. Create item pool with rarities
4. Balance difficulty curve
5. Add more themes

---

## BUILD & RUN

**Requirements**:
- Windows OS
- Visual Studio 2019+ (or VS Code with C# extensions)
- .NET Framework 4.7.2 SDK

**Build Command**:
```
msbuild MonsterDungeon.csproj /p:Configuration=Release
```

**Run**:
- Press F5 in Visual Studio (Debug mode)
- Or run compiled .exe from bin/Debug or bin/Release

**Current Behavior**:
Application launches with dark-themed window displaying "Monster Dungeon v0.1.0-alpha" header. Main content area is empty (ready for game views).

---

## VERSION INFORMATION

**Application Version**: v0.1.0-alpha
**Framework**: .NET Framework 4.7.2
**Language**: C# 8.0+
**Date**: 2024

**Package Versions** (Key Dependencies):
- CommunityToolkit.Mvvm: 8.4.0
- Microsoft.Extensions.Hosting: 8.0.0
- Microsoft.Extensions.DependencyInjection: 8.0.0
- System.Text.Json: 8.0.0
- MahApps.Metro: 2.4.11
- FontAwesome.Sharp: 6.6.0

---

## CONTACT & REPOSITORY

**GitHub Repository**: https://github.com/tristansinclair77/MonsterDungeon
**Branch**: master
**Project Directory**: D:\MonsterDungeon\MonsterDungeon

---

## TROUBLESHOOTING NOTES

### Common Issues:

1. **Build Errors with Source Generators**:
   - Ensure ViewModels are `partial` classes
   - Rebuild solution to regenerate source code

2. **DI Resolution Failures**:
   - Check all services are registered in `App.xaml.cs`
   - Verify constructors match registered services

3. **XAML Designer Issues**:
   - Designer may not resolve DataContext types
   - Build project first, then reopen XAML files

4. **Package Restore Problems**:
   - Right-click solution ? Restore NuGet Packages
   - Clean solution and rebuild

---

## GLOSSARY

- **MVVM**: Model-View-ViewModel (architectural pattern)
- **DDD**: Domain-Driven Design (software design approach)
- **DI**: Dependency Injection (design pattern)
- **GDD**: Game Design Document (game specification)
- **HP**: Health Points
- **XP**: Experience Points
- **ATK**: Attack stat
- **DEF**: Defense stat
- **UI**: User Interface
- **WPF**: Windows Presentation Foundation
- **XAML**: Extensible Application Markup Language

---

**End of Project Information Document**
**Last Updated**: Current session
**Status**: Project foundations complete, ready for gameplay implementation
